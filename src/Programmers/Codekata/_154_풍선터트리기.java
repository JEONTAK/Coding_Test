package Programmers.Codekata;

public class _154_풍선터트리기 {

    class Solution {
        public int solution(int[] a) {
            int n = a.length;

            if (n <= 2) {
                return n;
            }
            int answer = 2;
            int[] leftMin = new int[n];
            int[] rightMin = new int[n];
            leftMin[0] = a[0];
            rightMin[n - 1] = a[n - 1];

            for (int i = 1; i < n; i++) {
                leftMin[i] = Math.min(leftMin[i - 1], a[i]);
            }

            for (int i = n - 2; i >= 0; i--) {
                rightMin[i] = Math.min(rightMin[i + 1], a[i]);
            }

            for (int i = 1; i < n - 1; i++) {
                if (leftMin[i] >= a[i] || rightMin[i] >= a[i]) {
                    answer++;
                }
            }
            return answer;
        }
    }

}

/*
문제 분석
1. 정보
    - 일렬로 나열된 n개의 풍선이 존재.
    - 모든 풍선에는 서로 다른 숫자가 써져 있음.
    - 다음 과정을 반복하면서 풍선이 1개만 남을때까지 계속 터트려야 함.
        - 임의의 인접한 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트림
        - 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착
    - 인접한 두 풍선 중에서 번호가 더 작은 풍선을 터트리는 행위는 최대 1번만 가능
    - 즉 어떤 시점에서 인접한 두 풍선 중 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만 터트리기 가능
    - 어떤 풍선이 최후까지 남을 수 있는지 알고 싶음.
    - 위 조건대로 풍선을 터트리다 보면, 어떤 풍선은 남을 수 있지만, 어떤 풍선은 절대 마지막까지 남길 수 없음
2. 목표
    - 일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어짐.
    - 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return
3. 제약 조건
    - a의 길이는 1 이상 1,000,000 이하
        - a[i] 는 i + 1 번째 풍선에 써진 숫자를 의미.
        - a의 모든 수는 -10억 이상 10억 이하인 정수
        - a의 모든 수는 서로 다름

풀이
1. 아이디어
    - 핵심은 a[i] 풍선이 마지막까지 남을 수 있는 조건을 알아내야 함.
    - a[i]가 남기 위해선
        - 1. a[i] 기준 왼쪽 풍선의 최소값보다 작고, 오른쪽 풍선의 최소값보다 작으면 가능.
        - 2. a[i] 기준 왼쪽 풍선들보다 작고, 오른쪽 풍선의 최소값보다 커도 가능.
        - 3. a[i] 기준 왼쪽 풍선의 최소값보다 크고, 오른쪽 풍선의 최소값보다 작아도 가능
        - 커도 되는 이유는 단 한 번 번호가 작은 풍선을 터트릴 수 있기 때문.
    - 즉, a[i]가 남기 위해선
        - a[i] 기준 왼쪽 풍선들의 최소값보다 작거나
        - a[i] 기준 오른쪽 풍선들의 최소값보다 작으면
        - 해당 풍선을 마지막 까지 남길 수 있음.
    - 따라서 해당 문제를 풀기 위해서
        - 왼쪽 최소값과 오른쪽 최소값을 담기 위한 배열을 준비
            - 배열은 i 기준 
                - 왼쪽 최소값 배열은 0 ~ i - 1 까지의 번호 중 최소 값
                - 오른쪽 최소값 배열은 i + 1 ~ a 길이까지의 번호 중 최소 값을 의미
        - a의 배열을 모두 순회
            - i번에서의 번호가 왼쪽 최소값보다 작거나, 오른쪽 최소값보다 작다면 마지막까지 남길 수 있으므로 answer에 1 추가
            - 여기서 추가로, 양 끝 풍선은 항상 남길 수 있음
                - ex) 가장 왼쪽에 있는 풍선을 제외하고 모든 풍선들을 계속 큰 번호를 터트려 오른쪽에는 풍선 1개만 남음.
                    - 이때 가장 왼쪽을 무조건 남길 수 있기 때문
                - 오른쪽 풍선도 같은 의미로 남길 수 있음.
*/
