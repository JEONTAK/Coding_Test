package Programmers.Codekata;

import java.util.Stack;

public class _106_택배상자 {

    class Solution {
        public int solution(int[] order) {
            int answer = 0;
            Stack<Integer> s = new Stack<>();
            int idx = 0;
            for (int i = 1; i <= order.length; i++) {
                if (order[idx] == i) {
                    answer++;
                    idx++;

                    while (!s.isEmpty()) {
                        if (s.peek() == order[idx]) {
                            s.pop();
                            answer++;
                            idx++;
                        }else{
                            break;
                        }
                    }
                }else{
                    s.push(i);
                }

            }
            return answer;
        }
    }

}

/*
문제 분석
1. 정보
    - 영재는 택배상자를 트럭에 싣는 일을 한다.
    - 실어야 하는 택배상자는 크기가 모두 같고, 1번 상자부터 n번 상자까지 번호가 증가하는 순서대로 컨베이어 벨트에 일렬로 놓여 영재에게 전달된다.
    - 컨베이어 벨트는 한 방향으로만 진행이 가능하여 놓인 순서대로 상자를 내릴 수 있음
    - 하지만 벨트에 놓인 순서대로 상자를 내려 트럭에 싣게 되면 기사가 배달하는 순서와 상자가 실려있는 순서가 맞지 않아 배달에 차질이 생김
    - 만약 컨베이어 벨트의 맨 앞에 놓인 상자가 현재 트럭에 실어야 하는 순서가 아니라면, 그 상자를 트럭에 실을 순서가 될 때 까지 보조 컨베이어 벨트에 놓음
    - 보조 컨베이어 벨트는 앞 뒤로 이동이 가능하지만 입구 외에 다른 면이 막혀 있어 맨 앞의 상자만 뺄 수 있다.
    - 보조 컨베이어 벨트를 사용해도 기사님이 원하는 순서대로 상자를 싣지 못하면, 더 이상 상자를 싣지 않는다.

2. 목표
    - 실을 수 있는 상자의 최대 개수를 return
3. 제약 조건
    - 1 <= 상자 순서 <= 1000000
    - 상자 순서는 1 이상 길이 이하의 모든 정수가 한번씩 등장

풀이
1. 아이디어
    - 보조 컨베이어 벨트를 의미하는 stack을 하나 생성
    - 만약 현재 원하는 순서에 맞는 상자가 들어온다면, 상자 쌓음(순서++)
    - 원하는 순서의 상자가 들어오지 않는다면, stack에 저장.
    - stack이 비어있지 않을 경우, stack.peek() 통해 원하는 순서의 값을 뽑을 수 있는지 확인.
        - 뽑을 수 있다면, stack.pop 통해 해당 값 정리
        - 순서++
    - 만약 스택이 비어있지 않고, 원하는 값을 뽑지 못하였다면, 그대로 종료
*/
